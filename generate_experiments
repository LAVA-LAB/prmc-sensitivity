# %run "~/documents/sensitivity-prmdps/prmdp-sensitivity-git/generate_slipgrid_pmc.py"

import numpy as np
import json
import os
import math
from pathlib import Path
from datetime import datetime
from models.generate_slipgrids import generate_slipgrid, generate_pmc_random_drn, \
    generate_pmc_learning_drn

ROOT_DIR = os.path.dirname(os.path.abspath(__file__))

# %%
##########################################
# Generate motivating example from paper #

np.random.seed(4)

# Set ID's of terrain types
terrain = np.array([
    [1, 1, 3, 3, 3],
    [2, 1, 3, 3, 4],
    [2, 1, 4, 4, 4],
    [2, 2, 2, 5, 5],
    [2, 2, 2, 5, 5]
    ])

# Set slipping probabilities (v1 corresponds with terrin type 1)
slipping_probabilities = {
    'v1': 0.25,
    'v2': 0.40,
    'v3': 0.45,
    'v4': 0.50,
    'v5': 0.35
    }

# Generate rough estimate of the slipping probabilities
N = {
     'v1': 12,
     'v2': 18*2,
     'v3': 15*2,
     'v4': 30*2,
     'v5': 11*2
     }

# 0 = right, 1 = down, 2 = left, 3 = up
# Policy before the package has been picked up
policy_before = np.array([
    [0, 1, 1, 1, 1],
    [0, 1, 1, 0, 1],
    [0, 0, 0, 0, 3],
    [0, 3, 3, 3, 3],
    [0, 3, 3, 3, 3]
    ])

# Policy after the package has been picked up
policy_after = np.array([
    [0, 1, 1, 1, 1],
    [0, 1, 1, 1, 1],
    [0, 0, 1, 1, 1],
    [0, 1, 1, 1, 1],
    [0, -1, 2, 2, 2]
    ])

model_name = "models/slipgrid/dummy"

loc_package   = (4, 1)
loc_warehouse = (1, 4)

generate_slipgrid(ROOT_DIR, N, slipping_probabilities, policy_before, 
                  policy_after, terrain, model_name, loc_package, loc_warehouse)

# %%

##############################################
# Generate random slipgrids of varying sizes #

cases = [
    (10,    10),
    (20,    100),
    (50,    50),
    (50,    100),
    (50,    1000),
    (100,   100),
    (100,   1000),
    (200,   100),
    (200,   1000),
    (200,   10000),
    (400,   100),
    (400,   1000),
    (400,   10000),
    (800,   100),
    (800,   1000),
    (800,   10000)
    ]

slipping_prob_range = [0.10, 0.20]

# Number of parameters to estimate probabilities with
Nmin = 500
Nmax = 1000

iterations = 1

BASH_FILE = ["#!/bin/bash",
             "cd ..;",
             'echo -e "START GRID WORLD EXPERIMENTS...";']

number_derivatives = [1, 10]

dt = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")

for num_derivs in number_derivatives:
  for (Z,V) in cases:
    for mode in ['double']:  
        for seed in range(iterations):
            
            # Set the random seed
            np.random.seed(seed)
                    
            # Set the sample size for each parameter
            N = np.array(np.random.uniform(low=Nmin, high=Nmax, size=V), dtype=int)
            
            model_name = "models/slipgrid/{}_pmc_size={}_params={}_seed={}".format(mode,Z,V,seed)
            
            # By default, put package in top right corner and warehouse in bottom left
            loc_package   = (Z-2, 1)
            loc_warehouse = (1, Z-2)
            
            if V > Z**2:
                print('Skip configuration, because no. params exceed no. states.')
                continue
            
            # Set ID's of terrain types
            terrain = np.random.randint(low = 0, high = V, size=(Z,Z))
            
            # Set slipping probabilities (v1 corresponds with terrin type 1)
            slipping_probabilities = {
                'v'+str(i): np.random.uniform(slipping_prob_range[0], 
                                              slipping_prob_range[1]) for i in range(V)
                }
            
            # Minimum transition probability estimate
            delta = 1e-4
            
            # Obtain point estimates for each of the transition probabilities
            slipping_estimates = {}
            for i,(v,p) in enumerate(slipping_probabilities.items()):
                
                slipping_estimates[v] = [max(min(np.random.binomial(N[i], p) / N[i], 1-delta), delta), int(N[i])]
               
            json_path  = str(Path(ROOT_DIR, str(model_name)+'.json'))
            with open(r'{}.json'.format(str(Path(ROOT_DIR, str(model_name)))), 'w') as fp:
                json.dump(slipping_probabilities, fp)
                
            json_mle_path  = str(Path(ROOT_DIR, str(model_name)+'_mle.json'))
            with open(r'{}_mle.json'.format(str(Path(ROOT_DIR, str(model_name)))), 'w') as fp:
                json.dump(slipping_estimates, fp)
            
            # Scale reward with the size of the grid world
            reward = 10**(-math.floor(math.log(Z**2, 10)))
            
            drn_path = generate_pmc_random_drn(ROOT_DIR, N, terrain, model_name,
                                    loc_package, loc_warehouse, reward, slipmode = mode)
            
            prefix_pmc  = ["timeout 3600s python3 run_pmc.py"]
            prefix_prmc = ["timeout 3600s python3 run_prmc.py"]
            
            command = ['--instance "grid({},{},{})"'.format(Z,V,mode),
                       "--model '{}'".format(drn_path),
                       "--parameters '{}'".format(json_mle_path),
                       "--formula 'Rmin=? [F \"goal\"]'",
                       # "--validate_delta -0.001",
                       "--output_folder 'output/slipgrid_{}/'".format(dt),
                       "--num_deriv {}".format(num_derivs),
                       "--explicit_baseline",
                       "--robust_bound 'lower'",
                       "--scale_reward"]
            
            if num_derivs > 1:
                command += ["--no_gradient_validation"]
            
            BASH_FILE += [" ".join(prefix_pmc + command)+";"]
            
            if not ((Z >= 400) or (Z >= 200 and V > 100)):
                BASH_FILE += [" ".join(prefix_prmc + command)+";"]
        
BASH_FILE += ["#", "python3 create_table.py --folder 'output/slipgrid_{}/' --table_name 'tables/slipgrid_table_{}'".format(dt, dt)]
        
# Export bash file to perform grid world experiments
with open(str(Path(ROOT_DIR,'experiments/grid_world.sh')), 'w') as f:
    f.write("\n".join(BASH_FILE))
    
# %%

#################################################
# Generate slipgrids for the learning framework #

np.random.seed(0)

cases = [
    (20,   100),
    ]

slipping_prob_range = [0.10, 0.50]

# Number of samples to estimate probabilities with
Nmin = 100
Nmax = 100

SEEDS = [0]
BIAS = True

dt = datetime.now().strftime("_%Y_%m_%d_%H_%M_%S")

for (Z,V) in cases:
    for mode in ['double']:
      
        N = np.array(np.random.uniform(low=Nmin, high=Nmax, size=V), dtype=int)
          
        for seed in SEEDS:
                    
            np.random.seed(seed)
                    
            model_name = "models/slipgrid_learning/{}_pmc_size={}_params={}_seed={}".format(mode,Z,V,seed)
            
            # By default, put package in top right corner and warehouse in bottom left
            loc_package   = (Z-1, 0)
            loc_warehouse = (0, Z-1)
            
            if V > Z**2:
                print('Skip configuration, because no. params exceed no. states.')
                continue
            
            # Set ID's of terrain types
            if BIAS:
                
                order = np.arange(0, V)
                np.random.shuffle(order)
                
                listA = np.random.randint(low=0, high=10, size=int(Z**2/2))
                terrainA = order[listA]
                listB = np.random.randint(low=10, high=30, size=int(Z**2/4))
                terrainB = order[listB]
                listC = np.random.randint(low=30, high=V, size=int(Z**2/4))
                terrainC = order[listC]
            
                terrain = np.concatenate((terrainA, terrainB, terrainC))
                np.random.shuffle(terrain)
                terrain = np.reshape(terrain, (Z,Z))
            
            else:
                terrain = np.random.randint(low = 0, high = V, size=(Z,Z))
            
            print('Terrain:')
            print(terrain)
            for w in range(V):
                print(w,':',len(np.where(terrain == w)[0]))
                        
            # Set slipping probabilities (v1 corresponds with terrin type 1)
            slipping_probabilities = {
                'v'+str(i): np.random.uniform(slipping_prob_range[0], 
                                              slipping_prob_range[1]) for i in range(V)
                }
            
            # Minimum transition probability estimate
            delta = 1e-4
            
            # Obtain point estimates for each of the transition probabilities
            slipping_estimates = {}
            for i,(v,p) in enumerate(slipping_probabilities.items()):
                
                slipping_estimates[v] = [max(min(np.random.binomial(N[i], p) / N[i], 1-delta), delta), int(N[i])]
               
            json_path  = str(Path(ROOT_DIR, str(model_name)+'.json'))
            with open(r'{}.json'.format(str(Path(ROOT_DIR, str(model_name)))), 'w') as fp:
                json.dump(slipping_probabilities, fp)
                
            json_mle_path  = str(Path(ROOT_DIR, str(model_name)+'_mle.json'))
            with open(r'{}_mle.json'.format(str(Path(ROOT_DIR, str(model_name)))), 'w') as fp:
                json.dump(slipping_estimates, fp)
            
            # Scale reward with the size of the grid world
            reward = 10**(-math.floor(math.log(Z**2, 10)))
            
            drn_path = generate_pmc_learning_drn(ROOT_DIR, N, terrain, model_name,
                                    loc_package, loc_warehouse, reward, slipmode = mode)
    